# 给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。

# 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

# "123"
# "132"
# "213"
# "231"
# "312"
# "321"
# 给定 n 和 k，返回第 k 个排列。

# 说明：

# 给定 n 的范围是 [1, 9]。
# 给定 k 的范围是[1,  n!]。
# 示例 1:

# 输入: n = 3, k = 3
# 输出: "213"
# 示例 2:

# 输入: n = 4, k = 9
# 输出: "2314"
'''
假如n = 4, k = 14
首先考虑能不能确定第k个排列是以哪个数字开头的呢，以[1,2,3,4]的全排列为例，找第14个排列
以1开头的排列总共有3!个，原因是第一个位置是1，剩下3个位置可以随便排列，有6个
以2开头的排列总共有3!个，原因是第一个位置是2，剩下3个位置可以随便排列，有6个
此时已经有12个排列
所以剩下的两个排列即第14个排列一定在以3开头的排列中
用这种方式继续缩减数量，以3开头的排列中最小的为[3,1,2,4]，3已经固定，那么就找[1,2,4]的全排列的第2个排列，就是整个排列的第14个排列
以1开头的排列共有2!个，原因是第二个位置是1，剩下2个位置可以随便排列，有2个
此时已经有两个排列，可以确定结果一定在以[3,1]开头的排列中，即[3,1,2,4]或[3,1,4,2]
继续缩减数量，以[3,1]开头的排列中最下的为[3,1,2,4]，[3,1]已经固定，那么就找[2,4]的全排列的第2个排列，就是[1,2,4]的全排列的第2个排列，也就是整个排列的第14个排列
以2开头的排列共有1!个，原因是第三个位置是2，剩下一个位置给4，有1个
以4开头的排列共有1!个，原因是第三个位置是4，剩下一个位置给12，有1个
此时已经有两个排列，可以确定结果是以4开头的排列，即[4,2]，所以结果为[3,1,4,2]
所以，可以每次确定一个大范围，在大范围的基础上进一步缩小范围，直到最后只有一个数字为止。遍历n遍即可'''
class Solution:
    def getPermutation(self, n, k):
        factorial = [1] * n
        sums = 1
        res = ''
        nums = []
        for i in range(0, n):
            sums *= (i + 1)
            factorial[i] = sums
            nums.append(i + 1)

        k -= 1 #位置索引都是从0开始的，如果索引从1开始，那么就不会有这么多问题，此时k为14，即要找第13个排列,为之后能直接使用0这个索引
        for i in range(1, n + 1):
            curr = k // factorial[n - i - 1]
            res += str(nums[curr])
            nums.remove(nums[curr])
            k = k -  factorial[n - i - 1] * curr

        return res

aa = Solution().getPermutation(4, 9)
print(aa)